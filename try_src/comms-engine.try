!head
	@@include head.try
	<script type="text/javascript" src="https://unpkg.com/marked@7.0.1/marked.min.js"></script>
!md
	# Communications Engine
	A Example of how the Communications Engine could be implemented.
	This is a JavaScript function that takes a markdown template and replaces placeholders like \`\`\`@name\`\`\` or \`\`\`@name.opt1\`\`\` with actual values fetched from an API:


!tryit
	function strip(s,tag) {
	  return s.replaceAll(tag,'');
	}


	async function fillMarkdownTemplate(template, apiFetchFunction) {
	  const placeholderRegex = /```@([\w\.]+)```/g;
	  let filledTemplate = template;

	  const matches = filledTemplate.match(placeholderRegex);

	  if (matches) {
	    for (const match of matches) {
	      
	      const placeholder = strip(match,'```').substring(1); // Remove the "@" symbol
	      const value = await apiFetchFunction(placeholder);

	      if (value !== null && value !== undefined) {
	        filledTemplate = filledTemplate.replace(match, value);
	      }
	    }
	  }

	  return filledTemplate;
	}




!md
	This function uses a regular expression to find placeholders like \`\`\`@name\`\`\` or \`\`\`@name.opt1\`\`\` in the template. 
	It then calls the provided API fetch function to get the corresponding value based on the placeholder. 
	If a value is obtained from the API, the function replaces the placeholder in the template with the actual value.

	Here's how you can use the function:
	To convert Markdown to HTML in JavaScript, you can use a library like "marked". Here's how you can use it along with the previously defined function to fill placeholders:

	1. First, install the "marked" library using npm or yarn:

   ```bash
   npm install marked
   ```

   ```javascript
	const markdownTemplate = `
	Hello \`\`\`@name\`\`\`,

	This is some content with an option: \`\`\`@name.opt1\`\`\`.

	Thank you!
	`;
	```


	The "marked" library's `marked` function is used to convert the filled markdown template into HTML. The resulting HTML content will be a rendered version of your filled t
	emplate, with placeholders replaced by values and the markdown syntax converted to HTML elements.

	# Some Helper Functions



	Some data to play with, somethis the api might fetch

!tryit
	var jsonData = {
	  "name": "John Doe",
	  "name.quality": "is very good",
	  "member": {
	    "name": {
	      "first": "John",
	      "last": "Doe"
	    },
	    "address": {
	      "streetLocation": "123 Main St, Apt 4B",
	      "city": "Anytown",
	      "state": "CA",
	      "zip5": "12345",
	      "zip9": "12345-6789"
	    },
	    "email": {
	      "primary": "john.doe@example.com",
	      "secondary": "johndoe.alt@example.com"
	    },
	    "phone": {
	      "cell": "555-123-4567",
	      "home": "555-987-6543"
	    },
	    "member_id": "123456789",
	    "isMinor": false
	  }
	};

	function getValueFromPath(path, data) {
	    let r = data && data[path];
  		if(r) return r;
		const keys = path.split('.');
	 	let value = data;

	 	for (const key of keys) {
		    if (value.hasOwnProperty(key)) {
		      value = value[key];
		    } else {
		      value = null;
		      break;
		    }
		}
		if(isObject(value)) {
		      value = flattenObjectValues(value);
		}
		return value;
	}

	function isObject(variable) {
  		return typeof variable === 'object' && variable !== null && !Array.isArray(variable);
	}

	function flattenObjectValues(obj) {
	  let flattened = '';

	  function traverse(value) {
	    if (typeof value === 'object' && value !== null) {
	      for (const key in value) {
	        traverse(value[key]);
	      }
	    } else {
	      flattened += value + ' ';
	    }
	  }

	  traverse(obj);
	  return flattened.trim(); // Remove trailing space
	}

	

!md


!tryit
	// Assume you have an API fetch function that fetches values based on placeholders
	async function apiFetchFunction(placeholder) {
	  // Replace this with your API logic to fetch values
	  // const values = {
	  //   name: 'John Doe',
	  //   'name.quality': 'is very good'
	  //   // Add other placeholder values here
	  // };

	  return jsonData[placeholder] || getValueFromPath(placeholder,jsonData);
	}

	const markdownTemplate = `
	# Introduction
	Hello \`\`\`@name\`\`\`,

	Your quality is: \`\`\`@name.quality\`\`\`.

	Thank you!

	`;

	$$.HTML("<hr>")
	$$.D(markdownTemplate);
	$$.HTML("<HR>")
	var res = "";
	fillMarkdownTemplate(markdownTemplate, apiFetchFunction)
	  .then(filledTemplate => {
	    const htmlContent = marked.parse(filledTemplate);
	    res = htmlContent;
	    return htmlContent;
	  })
	  .catch(error => {
	    return (['Error:', error]);
	  });

			
!md
	Replace the placeholder values in the `apiFetchFunction` with your actual API logic to fetch values. The function `fillMarkdownTemplate` will return a filled template with placeholders replaced by their corresponding values fetched from the API.

!tryit
	$$.HTML(res)

!md 
	# An Interface

	Here's an example of an HTML form with a text area for entering a Markdown template and a button to generate the final message'

!tryit
    function genMessage() {
      const templateTextArea = document.getElementById('templateTextArea');
      const template = templateTextArea.value;

      fillMarkdownTemplate(template, apiFetchFunction)
        .then(filledTemplate => {
          const markedHtml = marked.parse(filledTemplate); // Assuming you've imported the "marked" library
          const outputDiv = document.getElementById('output');
          outputDiv.innerHTML = markedHtml;
        })
        .catch(error => {
          const outputDiv = document.getElementById('output');
          outputDiv.innerHTML = "Error: "+error;
        });
    }

    var generateButton = document.getElementById('generateButton');
    generateButton.addEventListener('click', genMessage);
  
	let timeoutId;

	function handleTextareaChange() {
	      clearTimeout(timeoutId);

	      timeoutId = setTimeout(() => {
	         genMessage();
	      }, 1000); // 1 second delay
	}

	let inputTextarea = document.getElementById('templateTextArea');
	inputTextarea.addEventListener('input', handleTextareaChange);



!html
  <b>Markdown Template Generator</b>
  <form id="templateForm">
    <label for="templateTextArea">Enter Markdown Template:</label><br>
    <textarea id="templateTextArea" rows="20" cols="150">
	# Introduction
	Hello ```@member.name```,

	Your ID: ```@member.member_id```
	Your quality is: ```@name.quality```.

	Thank you!


    </textarea><br>
    <button type="button" id="generateButton">Generate Message</button>
  </form>
  <div class="ui accordion">
  	<div class="title active">
  		<i class="dropdown icon"></i>
  		Output Doc
  	</div>
  	<div class="content active">
		<div id="output" style="background-color: #eeeeee; border-style: solid; padding: 10px"></div>
  
  	</div>
  </div>
  <br>
  <hr>
  <br>

!md

In this example, we've created a simple HTML form with a text area to input the Markdown 
template and a button to trigger the `genMessage` function. When the button is clicked, 
the `genMessage` function will read the content of the text area, call the `fillMarkdownTemplate` 
function to fill the placeholders, and then convert the filled template to HTML using the "marked" library. 
The HTML output will be displayed in a `<div>` with the id "output".

Remember to adjust the code according to your needs, especially the `fillMarkdownTemplate` and `apiFetchFunction` 
functions based on your requirements and data sources.